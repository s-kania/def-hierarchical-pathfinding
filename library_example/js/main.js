/**
 * G≈Å√ìWNA APLIKACJA - ≈ÅƒÑCZY WSZYSTKIE MODU≈ÅY
 */

import { 
    DEFAULT_SETTINGS, 
    DEFAULT_ISLAND_SETTINGS, 
    DEFAULT_PATHFINDING_SETTINGS 
} from './config/Settings.js';

import { MapGenerator } from './core/MapGenerator.js';
import { ChunkManager } from './core/ChunkManager.js';
import { TransitionPointManager } from './pathfinding/TransitionPointManager.js';
import { PathfindingPointManager } from './pathfinding/PathfindingPointManager.js';
import { CanvasRenderer } from './rendering/CanvasRenderer.js';
import { UIController } from './ui/UIController.js';
import { PathfindingUIController } from './ui/PathfindingUIController.js';
import { Inspector } from './ui/Inspector.js';
import { GameDataManager } from './data/GameDataManager.js';
import { getCanvasCoordinates } from './utils/MathUtils.js';

/**
 * G≈Å√ìWNA KLASA APLIKACJI
 */
class ChunkMapGenerator {
    constructor() {
        // Ustawienia
        this.settings = { ...DEFAULT_SETTINGS };
        this.islandSettings = { ...DEFAULT_ISLAND_SETTINGS };
        this.pathfindingSettings = { ...DEFAULT_PATHFINDING_SETTINGS };
        
        // G≈Ç√≥wne dane aplikacji
        this.chunks = [];
        this.baseMap = null;
        this.mapDimensions = { width: 0, height: 0 };
        
        // Komponenty
        this.mapGenerator = null;
        this.chunkManager = null;
        this.transitionPointManager = null;
        this.pathfindingPointManager = null;
        this.renderer = null;
        this.uiController = null;
        this.pathfindingUIController = null;
        this.inspector = null;
        this.gameDataManager = null;
        
        // Elementy DOM
        this.canvas = null;
        this.inspectorPanel = null;
        
        this.init();
    }
    
    init() {
        // Inicjalizuj elementy DOM
        this.canvas = document.getElementById('mapCanvas');
        this.inspectorPanel = document.getElementById('transitionPointDetails');
        
        if (!this.canvas) {
            console.error('‚ùå Canvas element not found!');
            return;
        }
        
        // Inicjalizuj komponenty
        this.initializeComponents();
        
        // Skonfiguruj UI
        this.setupUI();
        
        // Wygeneruj poczƒÖtkowƒÖ mapƒô
        this.generateMap();
        this.renderMap();
        this.updateStats();
        
        // Inicjalizuj pathfinding UI
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
        
        // Udostƒôpnij globalnie dla konsoli deweloperskiej
        window.mapGenerator = this;
        window.app = this;
        console.log('üéÆ MapGenerator dostƒôpny jako window.mapGenerator i window.app');
    }
    
    /**
     * INICJALIZUJE WSZYSTKIE KOMPONENTY
     */
    initializeComponents() {
        this.mapGenerator = new MapGenerator(this.settings, this.islandSettings);
        this.chunkManager = new ChunkManager(this.settings);
        this.transitionPointManager = new TransitionPointManager(this.settings, this.pathfindingSettings);
        this.pathfindingPointManager = new PathfindingPointManager(this.settings);
        this.renderer = new CanvasRenderer(this.canvas, this.settings, this.pathfindingSettings);
        this.uiController = new UIController(this.settings, this.islandSettings, this.pathfindingSettings);
        this.pathfindingUIController = new PathfindingUIController();
        this.inspector = new Inspector(this.inspectorPanel);
        this.gameDataManager = new GameDataManager(this.settings.chunkSize);
    }
    
    /**
     * KONFIGURUJE INTERFEJS U≈ªYTKOWNIKA
     */
    setupUI() {
        // Ustaw callbacki dla UI controllera
        this.uiController.setCallbacks({
            onFullRegenerationNeeded: () => this.onFullRegeneration(),
            onSmoothingOnlyNeeded: () => this.onSmoothingOnly(),
            onRenderOnlyNeeded: () => this.onRenderOnly(),
            onPathfindingUpdate: () => this.onPathfindingUpdate(),
            onExportPNG: () => this.onExportPNG(),
            onReset: () => this.onReset()
        });
        
        // Ustaw callbacki dla pathfinding UI
        this.pathfindingUIController.setCallbacks({
            onGenerateRandomPoints: () => this.onGenerateRandomPathfindingPoints(),
            onClearPoints: () => this.onClearPathfindingPoints(),
            onCalculatePath: () => this.onCalculatePathfindingPath(),
            onBuildTransitionGraph: () => this.onBuildTransitionGraph(),
            onPrintData: () => this.onPrintGameData()
        });
        
        // Skonfiguruj event listeners
        this.uiController.setupEventListeners();
        this.pathfindingUIController.setupEventListeners();
        
        // Skonfiguruj interaktywno≈õƒá canvas
        this.setupCanvasInteractivity();
    }
    
    /**
     * G≈Å√ìWNA METODA GENEROWANIA MAPY
     */
    generateMap() {
        console.log('üó∫Ô∏è Generating unified map...');
        
        // Aktualizuj ustawienia w komponentach
        this.updateComponentSettings();
        
        // Wyczy≈õƒá punkty pathfinding gdy generujemy nowƒÖ mapƒô
        this.pathfindingPointManager.clearPoints();
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
        
        // Generuj mapƒô
        const finalMap = this.mapGenerator.generateMap();
        
        // Podziel na chunki
        this.chunks = this.chunkManager.splitMapIntoChunks(
            finalMap, 
            this.mapGenerator.getMapDimensions().width, 
            this.mapGenerator.getMapDimensions().height
        );
        
        // Generuj punkty przej≈õcia
        this.transitionPointManager.generateTransitionPoints(this.chunks);
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        
        // Aktualizuj GameDataManager z punktami przej≈õcia
        this.updateGameDataManager();
        
        // Zapisz referencje dla kompatybilno≈õci
        this.baseMap = this.mapGenerator.getBaseMap();
        this.mapDimensions = this.mapGenerator.getMapDimensions();
        
        console.log(`‚úì Generated ${this.chunks.length} chunks from unified map`);
    }
    
    /**
     * APLIKUJE TYLKO SMOOTHING (OPTYMALIZACJA)
     */
    applySmoothingToExistingMap() {
        console.log('üîÑ Applying smoothing to existing map...');
        
        // Aktualizuj ustawienia
        this.updateComponentSettings();
        
        // Aplikuj smoothing
        const finalMap = this.mapGenerator.applySmoothingToExistingMap();
        
        // Podziel na chunki
        this.chunks = this.chunkManager.splitMapIntoChunks(
            finalMap,
            this.mapGenerator.getMapDimensions().width,
            this.mapGenerator.getMapDimensions().height
        );
        
        // Sprawd≈∫ czy istniejƒÖce punkty pathfinding sƒÖ nadal na oceanie
        this.validatePathfindingPoints();
        
        // Regeneruj punkty przej≈õcia
        this.transitionPointManager.generateTransitionPoints(this.chunks);
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        
        // Aktualizuj GameDataManager z punktami przej≈õcia
        this.updateGameDataManager();
        
        console.log(`‚úì Applied smoothing to existing map`);
    }
    
    /**
     * WALIDUJE PUNKTY PATHFINDING I USUWA NIEWA≈ªNE
     */
    validatePathfindingPoints() {
        let pointsRemoved = false;
        
        // Sprawd≈∫ punkt startowy
        if (this.pathfindingPointManager.getStartPoint()) {
            const startPoint = this.pathfindingPointManager.getStartPoint();
            const tilePos = this.pathfindingPointManager.pixelToTilePosition(startPoint.pixelX, startPoint.pixelY);
            
            if (!tilePos || !this.pathfindingPointManager.isTileOcean(tilePos)) {
                console.log('‚ö†Ô∏è Punkt startowy nie jest ju≈º na oceanie - usuwam');
                this.pathfindingPointManager.startPoint = null;
                pointsRemoved = true;
            }
        }
        
        // Sprawd≈∫ punkt ko≈Ñcowy
        if (this.pathfindingPointManager.getEndPoint()) {
            const endPoint = this.pathfindingPointManager.getEndPoint();
            const tilePos = this.pathfindingPointManager.pixelToTilePosition(endPoint.pixelX, endPoint.pixelY);
            
            if (!tilePos || !this.pathfindingPointManager.isTileOcean(tilePos)) {
                console.log('‚ö†Ô∏è Punkt ko≈Ñcowy nie jest ju≈º na oceanie - usuwam');
                this.pathfindingPointManager.endPoint = null;
                pointsRemoved = true;
            }
        }
        
        // Zaktualizuj UI je≈õli jakie≈õ punkty zosta≈Çy usuniƒôte
        if (pointsRemoved) {
            this.pathfindingUIController.updateAll(this.pathfindingPointManager);
        }
    }
    
    /**
     * RENDERUJE MAPƒò
     */
    renderMap() {
        const transitionPoints = this.transitionPointManager.getTransitionPoints();
        const selectedPoint = this.inspector.getSelectedPoint();
        
        this.renderer.renderMap(
            this.chunks, 
            this.chunkManager, 
            transitionPoints, 
            selectedPoint,
            this.pathfindingPointManager
        );
    }
    
    /**
     * AKTUALIZUJE USTAWIENIA W KOMPONENTACH
     */
    updateComponentSettings() {
        this.mapGenerator.updateSettings(this.settings);
        this.mapGenerator.updateIslandSettings(this.islandSettings);
        this.pathfindingPointManager.updateSettings(this.settings);
        this.renderer.updateSettings(this.settings);
        this.renderer.updatePathfindingSettings(this.pathfindingSettings);
    }
    
    /**
     * AKTUALIZUJE STATYSTYKI
     */
    updateStats() {
        const transitionPoints = this.transitionPointManager.getTransitionPoints();
        this.uiController.updateStats(this.chunks, transitionPoints);
    }
    
    /**
     * CALLBACKI UI
     */
    onFullRegeneration() {
        this.generateMap();
        this.renderMap();
        this.updateStats();
    }
    
    onSmoothingOnly() {
        this.applySmoothingToExistingMap();
        this.renderMap();
        this.updateStats();
    }
    
    onRenderOnly() {
        this.updateComponentSettings();
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        this.renderMap();
    }
    
    onPathfindingUpdate() {
        this.transitionPointManager.generateTransitionPoints(this.chunks);
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        this.renderMap();
        this.updateStats();
    }
    
    onExportPNG() {
        this.renderer.exportToPNG(
            this.islandSettings.preset, 
            this.settings.chunkCols, 
            this.settings.chunkRows
        );
    }
    
    /**
     * RESETUJE DO DOMY≈öLNYCH USTAWIE≈É
     */
    onReset() {
        console.log('üîÑ Resetting to defaults...');
        
        // Reset punkt√≥w pathfinding
        this.pathfindingPointManager.clearPoints();
        
        // Reset ustawie≈Ñ UI
        this.uiController.resetToDefaults();
        
        // Regeneruj mapƒô
        this.generateMap();
        this.renderMap();
        this.updateStats();
        
        // Aktualizuj UI pathfinding po resecie
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
    }

    /**
     * GENERUJE LOSOWE PUNKTY PATHFINDING
     */
    onGenerateRandomPathfindingPoints() {
        console.log('üé≤ Generowanie losowych punkt√≥w pathfinding...');
        const success = this.pathfindingPointManager.generateRandomPoints(this.chunks);
        
        if (success) {
            this.pathfindingUIController.showSuccess('Wygenerowano losowe punkty');
        } else {
            this.pathfindingUIController.showError('Nie mo≈ºna wygenerowaƒá punkt√≥w - brak wystarczajƒÖcej ilo≈õci oceanu');
        }
        
        this.renderMap();
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
    }

    /**
     * CZY≈öCI PUNKTY PATHFINDING
     */
    onClearPathfindingPoints() {
        console.log('üóëÔ∏è Czyszczenie punkt√≥w pathfinding...');
        this.pathfindingPointManager.clearPoints();
        this.pathfindingUIController.showSuccess('Wyczyszczono punkty');
        this.renderMap();
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
    }

    /**
     * OBLICZA ≈öCIE≈ªKƒò PATHFINDING
     */
    onCalculatePathfindingPath() {
        console.log('üß≠ Obliczanie ≈õcie≈ºki pathfinding...');
        
        if (!this.pathfindingPointManager.hasPoints()) {
            this.pathfindingUIController.showError('Brak punkt√≥w do obliczenia ≈õcie≈ºki');
            return;
        }
        
        // Tutaj mo≈ºna dodaƒá prawdziwy algorytm pathfinding
        const distance = this.pathfindingPointManager.calculateLinearDistance();
        this.pathfindingUIController.showSuccess(`Obliczono ≈õcie≈ºkƒô: ${distance.tiles} tiles`);
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
    }

    /**
     * KONFIGURUJE INTERAKTYWNO≈öƒÜ CANVAS Z OBS≈ÅUGƒÑ PATHFINDING
     */
    setupCanvasInteractivity() {
        // Obs≈Çuga ruchu myszy
        this.canvas.addEventListener('mousemove', (e) => {
            const { mouseX, mouseY } = getCanvasCoordinates(e, this.canvas);
            
            // Aktualizuj przeciƒÖganie punkt√≥w pathfinding
            if (this.pathfindingPointManager.isDraggingPoint()) {
                const success = this.pathfindingPointManager.updateDragging(mouseX, mouseY);
                if (success) {
                    this.renderMap();
                    this.pathfindingUIController.updateAll(this.pathfindingPointManager);
                }
                return;
            }
            
            // Sprawd≈∫ czy naje≈ºd≈ºamy na punkt pathfinding
            const pathfindingPoint = this.pathfindingPointManager.getPointAt(mouseX, mouseY);
            if (pathfindingPoint) {
                this.canvas.style.cursor = 'grab';
                return;
            }
            
            // Sprawd≈∫ punkty przej≈õcia (istniejƒÖca logika)
            if (!this.pathfindingSettings.showTransitionPoints) {
                this.inspector.hideInspector();
                this.canvas.style.cursor = 'default';
                return;
            }

            const hoveredPoint = this.transitionPointManager.getTransitionPointAt(mouseX, mouseY);
            if (hoveredPoint) {
                this.inspector.setHoveredPoint(hoveredPoint);
                this.canvas.classList.add('pointer-cursor');
                this.inspector.showInspector(hoveredPoint);
                this.canvas.style.cursor = 'pointer';
            } else {
                this.inspector.setHoveredPoint(null);
                this.canvas.classList.remove('pointer-cursor');
                this.canvas.style.cursor = 'default';
                
                if (this.inspector.getSelectedPoint()) {
                    this.inspector.showInspector(this.inspector.getSelectedPoint());
                } else {
                    this.inspector.hideInspector();
                }
            }
        });

        // Obs≈Çuga klikniƒôƒá myszy
        this.canvas.addEventListener('mousedown', (e) => {
            const { mouseX, mouseY } = getCanvasCoordinates(e, this.canvas);
            
            // Sprawd≈∫ czy klikniƒôto na punkt pathfinding
            const pathfindingPoint = this.pathfindingPointManager.getPointAt(mouseX, mouseY);
            if (pathfindingPoint) {
                this.pathfindingPointManager.startDragging(pathfindingPoint, mouseX, mouseY);
                this.pathfindingUIController.showDraggingMessage(pathfindingPoint.type);
                this.canvas.style.cursor = 'grabbing';
                return;
            }
            
            // Sprawd≈∫ punkty przej≈õcia (istniejƒÖca logika)
            if (this.pathfindingSettings.showTransitionPoints) {
                const clickedPoint = this.transitionPointManager.getTransitionPointAt(mouseX, mouseY);
                if (clickedPoint) {
                    this.inspector.setSelectedPoint(clickedPoint);
                    this.inspector.showInspector(clickedPoint);
                    this.renderMap();
                }
            }
        });

        // Obs≈Çuga puszczenia myszy
        this.canvas.addEventListener('mouseup', () => {
            if (this.pathfindingPointManager.isDraggingPoint()) {
                this.pathfindingPointManager.stopDragging();
                this.pathfindingUIController.updateAll(this.pathfindingPointManager);
                this.canvas.style.cursor = 'default';
            }
        });

        // Obs≈Çuga opuszczenia canvas
        this.canvas.addEventListener('mouseleave', () => {
            if (this.pathfindingPointManager.isDraggingPoint()) {
                this.pathfindingPointManager.stopDragging();
                this.pathfindingUIController.updateAll(this.pathfindingPointManager);
            }
            
            this.inspector.hideInspector();
            this.canvas.classList.remove('pointer-cursor');
            this.canvas.style.cursor = 'default';
        });
    }
    
    /**
     * AKTUALIZUJE GAMEDATA MANAGER Z PUNKTAMI PRZEJ≈öCIA I BUDUJE GRAF
     */
    updateGameDataManager() {
        if (!this.gameDataManager || !this.transitionPointManager) {
            return;
        }
        
        // Wyczy≈õƒá poprzednie punkty przej≈õcia
        this.gameDataManager.transitionPoints = [];
        
        // Pobierz punkty przej≈õcia z TransitionPointManager
        const transitionPoints = this.transitionPointManager.getTransitionPoints();
        
        // Konwertuj do nowego formatu i dodaj do GameDataManager
        transitionPoints.forEach(point => {
            // Sprawd≈∫ czy punkt ma wymagane w≈Ça≈õciwo≈õci
            if (point.chunkA && point.chunkB && point.x !== undefined && point.y !== undefined) {
                // Oblicz pozycjƒô lokalnƒÖ na podstawie kierunku
                let position;
                if (point.direction === 'vertical') {
                    position = point.x % this.settings.chunkSize;
                } else {
                    position = point.y % this.settings.chunkSize;
                }
                
                // Dodaj punkt z ID i connections
                this.gameDataManager.addTransitionPoint(point.chunkA, point.chunkB, position);
            }
        });
        
        // Graf po≈ÇƒÖcze≈Ñ bƒôdzie budowany na ≈ºƒÖdanie przez przycisk "Zbuduj Graf Przej≈õƒá"
        // this.gameDataManager.buildConnections(this.chunks);
        
        console.log(`‚úì GameDataManager updated with ${this.gameDataManager.transitionPoints.length} transition points`);
    }
    
    /**
     * BUDUJE GRAF PO≈ÅƒÑCZE≈É MIƒòDZY PUNKTAMI PRZEJ≈öCIA
     */
    onBuildTransitionGraph() {
        console.log('üîó Rƒôczne budowanie grafu po≈ÇƒÖcze≈Ñ...');
        
        // Upewnij siƒô ≈ºe mamy dane w GameDataManager
        if (!this.gameDataManager || this.gameDataManager.transitionPoints.length === 0) {
            this.pathfindingUIController.showError('Brak punkt√≥w przej≈õcia do zbudowania grafu');
            return;
        }
        
        // Buduj graf po≈ÇƒÖcze≈Ñ
        this.gameDataManager.buildConnections(this.chunks);
        
        // Drukuj statystyki grafu
        this.gameDataManager.printGraphStats();
        
        // Poka≈º sukces
        this.pathfindingUIController.showSuccess('Zbudowano graf po≈ÇƒÖcze≈Ñ');
    }

    /**
     * DRUKUJE DANE GAME DATA MANAGER W KONSOLI
     */
    onPrintGameData() {
        console.log('=== GAMEDATA MANAGER PRINT ===');
        console.log('üìä GameDataManager Object:', this.gameDataManager);
        
        console.log('\nüîó Transition Points (New Format with IDs):');
        console.table(this.gameDataManager.transitionPoints.map(point => ({
            id: point.id,
            chunks: point.chunks.join(' ‚Üî '),
            position: point.position,
            connections_count: point.connections.length,
            connections: point.connections.join(', ')
        })));
        
        console.log('\nüîÑ Converted to Default Format:');
        const defaultFormat = this.gameDataManager.convertTransitionPointsToDefault();
        console.table(defaultFormat);
        
        // Drukuj statystyki grafu
        this.gameDataManager.printGraphStats();
        
        console.log('\nüìê Settings:');
        console.log('- Chunk Size:', this.gameDataManager.chunkSize);
        console.log('- Total Transition Points:', this.gameDataManager.transitionPoints.length);
        
        console.log('\nüìã JSON Export (New Format):');
        console.log(JSON.stringify(this.gameDataManager.transitionPoints, null, 2));
        
        console.log('==============================');
        
        // Pokazuje te≈º sukces w UI
        this.pathfindingUIController.showSuccess('Dane wydrukowane w konsoli');
    }
}

// Inicjalizuj aplikacjƒô gdy DOM jest gotowy
document.addEventListener('DOMContentLoaded', () => {
    new ChunkMapGenerator();
}); 