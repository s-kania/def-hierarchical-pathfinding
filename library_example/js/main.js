/**
 * G≈Å√ìWNA APLIKACJA - ≈ÅƒÑCZY WSZYSTKIE MODU≈ÅY
 */

import { 
    DEFAULT_SETTINGS, 
    DEFAULT_ISLAND_SETTINGS, 
    DEFAULT_PATHFINDING_SETTINGS 
} from './config/Settings.js';

import { MapGenerator } from './core/MapGenerator.js';
import { ChunkManager } from './core/ChunkManager.js';
import { TransitionPointManager } from './pathfinding/TransitionPointManager.js';
import { PathfindingPointManager } from './pathfinding/PathfindingPointManager.js';
import { CanvasRenderer } from './rendering/CanvasRenderer.js';
import { UIController } from './ui/UIController.js';
import { PathfindingUIController } from './ui/PathfindingUIController.js';
import { Inspector } from './ui/Inspector.js';
import { GameDataManager } from './data/GameDataManager.js';
import { getCanvasCoordinates } from './utils/MathUtils.js';
import { HierarchicalPathfinding } from '../hierarchical_pathfinding/HierarchicalPathfinding.js';

/**
 * G≈Å√ìWNA KLASA APLIKACJI
 */
class ChunkMapGenerator {
    constructor() {
        // Ustawienia
        this.settings = { ...DEFAULT_SETTINGS };
        this.islandSettings = { ...DEFAULT_ISLAND_SETTINGS };
        this.pathfindingSettings = { ...DEFAULT_PATHFINDING_SETTINGS };
        
        // G≈Ç√≥wne dane aplikacji
        this.chunks = [];
        this.baseMap = null;
        this.mapDimensions = { width: 0, height: 0 };
        this.pathSegments = null; // Segmenty obliczonej ≈õcie≈ºki pathfinding
        
        // Komponenty
        this.mapGenerator = null;
        this.chunkManager = null;
        this.transitionPointManager = null;
        this.pathfindingPointManager = null;
        this.renderer = null;
        this.uiController = null;
        this.pathfindingUIController = null;
        this.inspector = null;
        this.gameDataManager = null;
        
        // Elementy DOM
        this.canvas = null;
        this.inspectorPanel = null;
        
        // Modal i zak≈Çadki
        this.settingsModal = null;
        this.currentTab = 'map-config';
        
        this.init();
    }
    
    init() {
        // Inicjalizuj elementy DOM
        this.canvas = document.getElementById('mapCanvas');
        this.inspectorPanel = document.getElementById('transitionPointDetails');
        this.settingsModal = document.getElementById('settingsModal');
        
        if (!this.canvas) {
            console.error('‚ùå Canvas element not found!');
            return;
        }
        
        // Inicjalizuj komponenty
        this.initializeComponents();
        
        // Skonfiguruj UI
        this.setupUI();
        
        // Skonfiguruj modal i zak≈Çadki
        this.setupModalAndTabs();
        
        // Wygeneruj poczƒÖtkowƒÖ mapƒô
        this.generateMap();
        this.renderMap();
        this.updateStats();
        
        // Inicjalizuj pathfinding UI
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
        
        // Udostƒôpnij globalnie dla konsoli deweloperskiej
        window.mapGenerator = this;
        window.app = this;
        window.gameDataManager = this.gameDataManager;
        console.log('üéÆ MapGenerator dostƒôpny jako window.mapGenerator i window.app');
        console.log('üìä GameDataManager dostƒôpny jako window.gameDataManager');
    }
    
    /**
     * INICJALIZUJE WSZYSTKIE KOMPONENTY
     */
    initializeComponents() {
        this.mapGenerator = new MapGenerator(this.settings, this.islandSettings);
        this.chunkManager = new ChunkManager(this.settings);
        this.transitionPointManager = new TransitionPointManager(this.settings, this.pathfindingSettings);
        this.pathfindingPointManager = new PathfindingPointManager(this.settings);
        this.renderer = new CanvasRenderer(this.canvas, this.settings, this.pathfindingSettings);
        this.uiController = new UIController(this.settings, this.islandSettings, this.pathfindingSettings);
        this.pathfindingUIController = new PathfindingUIController();
        this.gameDataManager = new GameDataManager(
            this.settings.chunkCols, 
            this.settings.chunkRows,
            this.settings.chunkSize,  // chunkWidth
            this.settings.chunkSize   // chunkHeight (dla kwadratowych chunk√≥w)
        );
        this.inspector = new Inspector(this.inspectorPanel, this.gameDataManager);
    }
    
    /**
     * KONFIGURUJE INTERFEJS U≈ªYTKOWNIKA
     */
    setupUI() {
        // Ustaw callbacki dla UI controllera
        this.uiController.setCallbacks({
            onFullRegenerationNeeded: () => this.onFullRegeneration(),
            onSmoothingOnlyNeeded: () => this.onSmoothingOnly(),
            onRenderOnlyNeeded: () => this.onRenderOnly(),
            onPathfindingUpdate: () => this.onPathfindingUpdate(),
            onExportPNG: () => this.onExportPNG(),
            onReset: () => this.onReset()
        });
        
        // Ustaw callbacki dla pathfinding UI
        this.pathfindingUIController.setCallbacks({
            onPrintData: () => this.onPrintGameData()
        });
        
        // Skonfiguruj event listeners
        this.uiController.setupEventListeners();
        this.pathfindingUIController.setupEventListeners();
        
        // Skonfiguruj interaktywno≈õƒá canvas
        this.setupCanvasInteractivity();
    }
    
    /**
     * KONFIGURUJE MODAL I ZAK≈ÅADKI
     */
    setupModalAndTabs() {
        // Przycisk Settings
        const settingsBtn = document.getElementById('settingsBtn');
        const closeModalBtn = document.getElementById('closeSettingsModal');
        
        if (settingsBtn) {
            settingsBtn.addEventListener('click', () => this.openSettingsModal());
        }
        
        if (closeModalBtn) {
            closeModalBtn.addEventListener('click', () => this.closeSettingsModal());
        }
        
        // Zamknij modal po klikniƒôciu poza nim
        if (this.settingsModal) {
            this.settingsModal.addEventListener('click', (e) => {
                if (e.target === this.settingsModal) {
                    this.closeSettingsModal();
                }
            });
        }
        
        // Zak≈Çadki
        const tabButtons = document.querySelectorAll('.tab-btn');
        tabButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tabName = e.target.dataset.tab;
                this.switchTab(tabName);
            });
        });
        
        // Zamknij modal po naci≈õniƒôciu Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.settingsModal.classList.contains('show')) {
                this.closeSettingsModal();
            }
        });
        
        // Przycisk "Oblicz ≈õcie≈ºkƒô" w g≈Ç√≥wnym layout
        this.setupCalculatePathButton();
    }
    
    /**
     * OTWIERA MODAL SETTINGS
     */
    openSettingsModal() {
        if (this.settingsModal) {
            this.settingsModal.classList.add('show');
            document.body.style.overflow = 'hidden'; // Zablokuj scrollowanie strony
        }
    }
    
    /**
     * ZAMYKA MODAL SETTINGS
     */
    closeSettingsModal() {
        if (this.settingsModal) {
            this.settingsModal.classList.remove('show');
            document.body.style.overflow = ''; // Przywr√≥ƒá scrollowanie strony
        }
    }
    
    /**
     * PRZE≈ÅƒÑCZA ZAK≈ÅADKƒò
     */
    switchTab(tabName) {
        // Usu≈Ñ aktywnƒÖ klasƒô ze wszystkich przycisk√≥w i paneli
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        
        // Dodaj aktywnƒÖ klasƒô do wybranej zak≈Çadki
        const activeTabBtn = document.querySelector(`[data-tab="${tabName}"]`);
        const activeTabPane = document.getElementById(tabName);
        
        if (activeTabBtn) {
            activeTabBtn.classList.add('active');
        }
        if (activeTabPane) {
            activeTabPane.classList.add('active');
        }
        
        this.currentTab = tabName;
    }
    
    /**
     * G≈Å√ìWNA METODA GENEROWANIA MAPY
     */
    generateMap() {

        
        // Aktualizuj ustawienia w komponentach
        this.updateComponentSettings();
        
        // Wyczy≈õƒá punkty pathfinding i ≈õcie≈ºkƒô gdy generujemy nowƒÖ mapƒô
        this.pathfindingPointManager.clearPoints();
        this.pathSegments = null;
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
        
        // Generuj mapƒô
        const finalMap = this.mapGenerator.generateMap();
        
        // Podziel na chunki
        this.chunks = this.chunkManager.splitMapIntoChunks(
            finalMap, 
            this.mapGenerator.getMapDimensions().width, 
            this.mapGenerator.getMapDimensions().height
        );
        
        // Generuj punkty przej≈õcia
        this.transitionPointManager.generateTransitionPoints(this.chunks);
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        
        // Aktualizuj GameDataManager z punktami przej≈õcia
        this.updateGameDataManager();
        
        // Automatycznie zbuduj graf po≈ÇƒÖcze≈Ñ
        if (this.gameDataManager.transitionPoints.length > 0) {
            this.gameDataManager.buildConnections(this.chunks);
        }
        
        // Automatycznie wygeneruj losowe punkty pathfinding
        this.generateRandomPathfindingPoints();
        
        // Aktualizuj UI po automatycznym generowaniu punkt√≥w
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
        
        // Zapisz referencje dla kompatybilno≈õci
        this.baseMap = this.mapGenerator.getBaseMap();
        this.mapDimensions = this.mapGenerator.getMapDimensions();
    }
    
    /**
     * APLIKUJE TYLKO SMOOTHING (OPTYMALIZACJA)
     */
    applySmoothingToExistingMap() {
        // Aktualizuj ustawienia
        this.updateComponentSettings();
        
        // Aplikuj smoothing
        const finalMap = this.mapGenerator.applySmoothingToExistingMap();
        
        // Podziel na chunki
        this.chunks = this.chunkManager.splitMapIntoChunks(
            finalMap,
            this.mapGenerator.getMapDimensions().width,
            this.mapGenerator.getMapDimensions().height
        );
        
        // Sprawd≈∫ czy istniejƒÖce punkty pathfinding sƒÖ nadal na oceanie
        this.validatePathfindingPoints();
        
        // Regeneruj punkty przej≈õcia
        this.transitionPointManager.generateTransitionPoints(this.chunks);
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        
        // Aktualizuj GameDataManager z punktami przej≈õcia
        this.updateGameDataManager();
        
        // Automatycznie zbuduj graf po≈ÇƒÖcze≈Ñ
        if (this.gameDataManager.transitionPoints.length > 0) {
            this.gameDataManager.buildConnections(this.chunks);
        }
    }
    
    /**
     * WALIDUJE PUNKTY PATHFINDING I USUWA NIEWA≈ªNE
     */
    validatePathfindingPoints() {
        let pointsRemoved = false;
        
        // Sprawd≈∫ punkt startowy
        if (this.pathfindingPointManager.getStartPoint()) {
            const startPoint = this.pathfindingPointManager.getStartPoint();
            const tilePos = this.pathfindingPointManager.pixelToTilePosition(startPoint.pixelX, startPoint.pixelY);
            
            if (!tilePos || !this.pathfindingPointManager.isTileOcean(tilePos)) {
                this.pathfindingPointManager.startPoint = null;
                pointsRemoved = true;
            }
        }
        
        // Sprawd≈∫ punkt ko≈Ñcowy
        if (this.pathfindingPointManager.getEndPoint()) {
            const endPoint = this.pathfindingPointManager.getEndPoint();
            const tilePos = this.pathfindingPointManager.pixelToTilePosition(endPoint.pixelX, endPoint.pixelY);
            
            if (!tilePos || !this.pathfindingPointManager.isTileOcean(tilePos)) {
                this.pathfindingPointManager.endPoint = null;
                pointsRemoved = true;
            }
        }
        
        // Zaktualizuj UI je≈õli jakie≈õ punkty zosta≈Çy usuniƒôte
        if (pointsRemoved) {
            this.pathfindingUIController.updateAll(this.pathfindingPointManager);
            
            // Automatycznie wygeneruj nowe punkty je≈õli wszystkie zosta≈Çy usuniƒôte
            if (!this.pathfindingPointManager.getStartPoint() && !this.pathfindingPointManager.getEndPoint()) {
                this.generateRandomPathfindingPoints();
            }
        }
    }
    
    /**
     * RENDERUJE MAPƒò
     */
    renderMap() {
        const transitionPoints = this.transitionPointManager.getTransitionPoints();
        const selectedPoint = this.inspector.getSelectedPoint();
        const hoveredPoint = this.inspector.getHoveredPoint();
        
        // U≈ºyj hoveredPoint je≈õli nie ma selectedPoint, lub selectedPoint je≈õli jest
        const activePoint = selectedPoint || hoveredPoint;
        
        // Przeka≈º selectedPoint i hoveredPoint do renderera
        this.renderer.selectedPoint = selectedPoint;
        this.renderer.hoveredPoint = hoveredPoint;
        
        this.renderer.renderMap(
            this.chunks, 
            this.chunkManager, 
            transitionPoints, 
            activePoint,
            this.pathfindingPointManager,
            this.gameDataManager,
            this.pathSegments
        );
    }
    
    /**
     * AKTUALIZUJE USTAWIENIA W KOMPONENTACH
     */
    updateComponentSettings() {
        this.mapGenerator.updateSettings(this.settings);
        this.mapGenerator.updateIslandSettings(this.islandSettings);
        this.pathfindingPointManager.updateSettings(this.settings);
        this.renderer.updateSettings(this.settings);
        this.renderer.updatePathfindingSettings(this.pathfindingSettings);
        
        // Aktualizuj GameDataManager z nowymi wymiarami chunka
        this.gameDataManager = new GameDataManager(
            this.settings.chunkCols, 
            this.settings.chunkRows,
            this.settings.chunkSize,  // chunkWidth
            this.settings.chunkSize   // chunkHeight (dla kwadratowych chunk√≥w)
        );
    }
    
    /**
     * AKTUALIZUJE STATYSTYKI
     */
    updateStats() {
        const transitionPoints = this.transitionPointManager.getTransitionPoints();
        this.uiController.updateStats(this.chunks, transitionPoints);
        
        // Aktualizuj Active Point ID
        this.updateActivePointId();
    }
    
    /**
     * AKTUALIZUJE ACTIVE POINT ID W SEKCJI NAD MAPƒÑ
     */
    updateActivePointId() {
        const activePointIdElement = document.getElementById('activePointId');
        if (!activePointIdElement) return;
        
        const selectedPoint = this.inspector.getSelectedPoint();
        const hoveredPoint = this.inspector.getHoveredPoint();
        // Priorytet dla hovered point, potem selected point
        const activePoint = hoveredPoint || selectedPoint;
        
        if (activePoint) {
            // Znajd≈∫ punkt w GameDataManager, aby uzyskaƒá poprawne ID
            const gdPoint = this.findGameDataPoint(activePoint);
            const pointId = gdPoint ? gdPoint.id : `${activePoint.chunkA}-${activePoint.chunkB}-${activePoint.x}-${activePoint.y}`;

            activePointIdElement.textContent = pointId;
            // Enable Print button
            const printBtn = document.getElementById('debugConnectionsBtn');
            if (printBtn) printBtn.disabled = false;
        } else {
            activePointIdElement.textContent = '-';
            // Disable Print button
            const printBtn = document.getElementById('debugConnectionsBtn');
            if (printBtn) printBtn.disabled = true;
        }
    }
    
    /**
     * ZNAJDUJE ODPOWIEDNI PUNKT W GAMEDATA MANAGER
     */
    findGameDataPoint(point) {
        if (!this.gameDataManager || !this.gameDataManager.transitionPoints) {
            return null;
        }

        // Szukaj punktu przej≈õcia w GameDataManager kt√≥ry odpowiada naszemu punktowi
        return this.gameDataManager.transitionPoints.find(gdPoint => {
            // Sprawd≈∫ czy chunk'i siƒô zgadzajƒÖ (w dowolnej kolejno≈õci)
            const [gdChunkA, gdChunkB] = gdPoint.chunks;
            const pointMatches = (gdChunkA === point.chunkA && gdChunkB === point.chunkB) ||
                                (gdChunkA === point.chunkB && gdChunkB === point.chunkA);
            
            if (!pointMatches) return false;
            
            // Sprawd≈∫ pozycjƒô na podstawie kierunku
            if (point.direction === 'horizontal') {
                // Dla punkt√≥w poziomych pozycja to Y wzglƒôdem chunka
                const localY = point.y % this.gameDataManager.chunkHeight;
                return gdPoint.position === localY;
            } else if (point.direction === 'vertical') {
                // Dla punkt√≥w pionowych pozycja to X wzglƒôdem chunka  
                const localX = point.x % this.gameDataManager.chunkWidth;
                return gdPoint.position === localX;
            }
            
            return false;
        });
    }
    
    /**
     * CALLBACKI UI
     */
    onFullRegeneration() {
        this.generateMap();
        this.renderMap();
        this.updateStats();
    }
    
    onSmoothingOnly() {
        this.applySmoothingToExistingMap();
        this.renderMap();
        this.updateStats();
    }
    
    onRenderOnly() {
        this.updateComponentSettings();
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        this.renderMap();
    }
    
    onPathfindingUpdate() {
        this.transitionPointManager.generateTransitionPoints(this.chunks);
        this.transitionPointManager.calculateTransitionPointPixels(this.chunks);
        this.renderMap();
        this.updateStats();
    }
    
    onExportPNG() {
        this.renderer.exportToPNG(
            this.islandSettings.preset, 
            this.settings.chunkCols, 
            this.settings.chunkRows
        );
    }
    
    /**
     * RESETUJE DO DOMY≈öLNYCH USTAWIE≈É
     */
    onReset() {
        // Reset punkt√≥w pathfinding i ≈õcie≈ºki
        this.pathfindingPointManager.clearPoints();
        this.pathSegments = null;
        
        // Reset ustawie≈Ñ UI
        this.uiController.resetToDefaults();
        
        // Regeneruj mapƒô (kt√≥ra automatycznie wygeneruje nowe punkty)
        this.generateMap();
        this.renderMap();
        this.updateStats();
        
        // Aktualizuj UI pathfinding po resecie
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
    }

    /**
     * GENERUJE LOSOWE PUNKTY PATHFINDING
     */
    /**
     * AUTOMATYCZNIE GENERUJE LOSOWE PUNKTY PATHFINDING
     */
    generateRandomPathfindingPoints() {
        const success = this.pathfindingPointManager.generateRandomPoints(this.chunks);
        
        if (!success) {
            console.log('‚ö†Ô∏è Nie mo≈ºna wygenerowaƒá punkt√≥w - brak wystarczajƒÖcej ilo≈õci oceanu');
        }
    }

    /**
     * CZY≈öCI PUNKTY PATHFINDING
     */
    onClearPathfindingPoints() {
        this.pathfindingPointManager.clearPoints();
        this.pathSegments = null; // Wyczy≈õƒá te≈º obliczonƒÖ ≈õcie≈ºkƒô
        this.pathfindingUIController.showSuccess('Wyczyszczono punkty');
        this.renderMap();
        this.pathfindingUIController.updateAll(this.pathfindingPointManager);
    }

    /**
     * OBLICZA ≈öCIE≈ªKƒò PATHFINDING
     */
    onCalculatePathfindingPath() {
        
        if (!this.pathfindingPointManager.hasPoints()) {
            this.pathfindingUIController.showError('Brak punkt√≥w do obliczenia ≈õcie≈ºki');
            return;
        }

        // NOWA IMPLEMENTACJA - HierarchicalPathfinding
        try {
            // Tworzymy nowƒÖ instancjƒô HierarchicalPathfinding
            const pathfinder = new HierarchicalPathfinding();
            
            // Konfiguracja z wymiarami chunka z ustawie≈Ñ
            const config = {
                tileSize: this.settings.tileSize,
                gridWidth: this.gameDataManager.gridWidth,
                gridHeight: this.gameDataManager.gridHeight,
                chunkWidth: this.gameDataManager.chunkWidth,
                chunkHeight: this.gameDataManager.chunkHeight,
                getChunkData: (chunkId) => this.gameDataManager.getChunkData(chunkId),
                transitionPoints: this.gameDataManager.transitionPoints
            };
            
            // Inicjalizuj pathfinder
            pathfinder.init(config);
            
            // Pobierz punkty start/end z PathfindingPointManager
            const startPoint = this.pathfindingPointManager.getStartPoint();
            const endPoint = this.pathfindingPointManager.getEndPoint();
            
            // Konwertuj pozycje tile na pozycje ≈õwiata (w jednostkach world)
            // PathfindingPointManager przechowuje numery tile'√≥w, ale biblioteca oczekuje pozycji ≈õwiata
            const startPos = {
                x: startPoint.x * this.settings.tileSize + this.settings.tileSize / 2,
                y: startPoint.y * this.settings.tileSize + this.settings.tileSize / 2,
                z: 0
            };
            
            const endPos = {
                x: endPoint.x * this.settings.tileSize + this.settings.tileSize / 2,
                y: endPoint.y * this.settings.tileSize + this.settings.tileSize / 2,
                z: 0
            };
            

            
            // Znajd≈∫ ≈õcie≈ºkƒô
            const pathSegments = pathfinder.findPath(startPos, endPos);
            
            if (pathSegments) {

                console.log('--- Obliczone segmenty ≈õcie≈ºki ---');
                const tableData = pathSegments.map(segment => ({
                    chunk: segment.chunk,
                    x: segment.position.x.toFixed(2),
                    y: segment.position.y.toFixed(2)
                }));
                console.table(tableData);
                console.log('------------------------------------');
                
                // Stw√≥rz kompletnƒÖ ≈õcie≈ºkƒô zaczynajƒÖcƒÖ siƒô od pozycji startowej
                const completePath = [];
                
                // Dodaj pozycjƒô startowƒÖ jako pierwszy punkt
                completePath.push({
                    chunk: 'start',
                    position: startPos
                });
                
                // Dodaj segmenty ≈õcie≈ºki z biblioteki
                completePath.push(...pathSegments);
                
                // Zapisz kompletnƒÖ ≈õcie≈ºkƒô do renderowania
                this.pathSegments = completePath;
                
                // Rerenderuj mapƒô z narysowanƒÖ ≈õcie≈ºkƒÖ
                this.renderMap();
                
                this.pathfindingUIController.showSuccess(`Znaleziono ≈õcie≈ºkƒô z ${pathSegments.length} segmentami`);
            } else {
                // Wyczy≈õƒá poprzedniƒÖ ≈õcie≈ºkƒô
                this.pathSegments = null;
                this.renderMap();
                this.pathfindingUIController.showError('Nie mo≈ºna znale≈∫ƒá ≈õcie≈ºki miƒôdzy punktami');
            }
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd podczas obliczania ≈õcie≈ºki:', error);
            this.pathfindingUIController.showError(`B≈ÇƒÖd: ${error.message}`);
        }
    }

    /**
     * KONFIGURUJE INTERAKTYWNO≈öƒÜ CANVAS Z OBS≈ÅUGƒÑ PATHFINDING
     */
    setupCanvasInteractivity() {
        // Obs≈Çuga ruchu myszy
        this.canvas.addEventListener('mousemove', (e) => {
            const { mouseX, mouseY } = getCanvasCoordinates(e, this.canvas);
            
            // Aktualizuj pozycjƒô myszy w UI
            this.uiController.updateMousePosition(mouseX, mouseY);
            
            // Aktualizuj przeciƒÖganie punkt√≥w pathfinding
            if (this.pathfindingPointManager.isDraggingPoint()) {
                const success = this.pathfindingPointManager.updateDragging(mouseX, mouseY);
                if (success) {
                    // Wyczy≈õƒá obliczonƒÖ ≈õcie≈ºkƒô bo punkty siƒô zmieni≈Çy
                    this.pathSegments = null;
                    this.renderMap();
                    this.pathfindingUIController.updateAll(this.pathfindingPointManager);
                }
                return;
            }
            
            // Sprawd≈∫ czy naje≈ºd≈ºamy na punkt pathfinding
            const pathfindingPoint = this.pathfindingPointManager.getPointAt(mouseX, mouseY);
            if (pathfindingPoint) {
                this.canvas.style.cursor = 'grab';
                return;
            }
            
            // Sprawd≈∫ punkty przej≈õcia (istniejƒÖca logika)
            if (!this.pathfindingSettings.showTransitionPoints) {
                this.inspector.hideInspector();
                this.canvas.style.cursor = 'default';
                return;
            }

            const hoveredPoint = this.transitionPointManager.getTransitionPointAt(mouseX, mouseY);
            const currentHoveredPoint = this.inspector.getHoveredPoint();
            
            // Sprawd≈∫ czy hover siƒô zmieni≈Ç (por√≥wnaj przez ID punkt√≥w)
            const getPointId = (point) => point ? `${point.chunkA}-${point.chunkB}-${point.x}-${point.y}` : null;
            const hoveredId = getPointId(hoveredPoint);
            const currentHoveredId = getPointId(currentHoveredPoint);
            const hoverChanged = hoveredId !== currentHoveredId;
            
            if (hoveredPoint) {
                this.inspector.setHoveredPoint(hoveredPoint);
                this.canvas.classList.add('pointer-cursor');
                this.inspector.showInspector(hoveredPoint, this.gameDataManager);
                this.canvas.style.cursor = 'pointer';
                
                // Renderuj mapƒô tylko je≈õli hover siƒô zmieni≈Ç
                if (hoverChanged) {
                    this.renderMap();
                    this.updateActivePointId();
                }
            } else {
                this.inspector.setHoveredPoint(null);
                this.canvas.classList.remove('pointer-cursor');
                this.canvas.style.cursor = 'default';
                
                if (this.inspector.getSelectedPoint()) {
                    this.inspector.showInspector(this.inspector.getSelectedPoint(), this.gameDataManager);
                } else {
                    this.inspector.hideInspector();
                }
                
                // Renderuj mapƒô tylko je≈õli hover siƒô zmieni≈Ç
                if (hoverChanged) {
                    this.renderMap();
                    this.updateActivePointId();
                }
            }
        });

        // Obs≈Çuga klikniƒôƒá myszy
        this.canvas.addEventListener('mousedown', (e) => {
            const { mouseX, mouseY } = getCanvasCoordinates(e, this.canvas);
            
            // Sprawd≈∫ czy klikniƒôto na punkt pathfinding
            const pathfindingPoint = this.pathfindingPointManager.getPointAt(mouseX, mouseY);
            if (pathfindingPoint) {
                this.pathfindingPointManager.startDragging(pathfindingPoint, mouseX, mouseY);
                this.pathfindingUIController.showDraggingMessage(pathfindingPoint.type);
                this.canvas.style.cursor = 'grabbing';
                return;
            }
            
            // Sprawd≈∫ punkty przej≈õcia (istniejƒÖca logika)
            if (this.pathfindingSettings.showTransitionPoints) {
                const clickedPoint = this.transitionPointManager.getTransitionPointAt(mouseX, mouseY);
                if (clickedPoint) {
                    this.inspector.setSelectedPoint(clickedPoint);
                    this.inspector.showInspector(clickedPoint, this.gameDataManager);
                    // Renderuj mapƒô z liniami po≈ÇƒÖcze≈Ñ dla selectedPoint
                    this.renderMap();
                    this.updateActivePointId();
                } else {
                    // Klikniƒôto poza punktem przej≈õcia - resetuj zaznaczenie
                    this.inspector.setSelectedPoint(null);
                    this.inspector.hideInspector();
                    // Renderuj mapƒô bez linii po≈ÇƒÖcze≈Ñ
                    this.renderMap();
                    this.updateActivePointId();
                }
            } else {
                // Punkty przej≈õcia sƒÖ wy≈ÇƒÖczone - resetuj zaznaczenie
                this.inspector.setSelectedPoint(null);
                this.inspector.hideInspector();
                this.renderMap();
                this.updateActivePointId();
            }
        });

        // Obs≈Çuga puszczenia myszy
        this.canvas.addEventListener('mouseup', () => {
            if (this.pathfindingPointManager.isDraggingPoint()) {
                this.pathfindingPointManager.stopDragging();
                this.pathfindingUIController.updateAll(this.pathfindingPointManager);
                this.canvas.style.cursor = 'default';
            }
        });

        // Obs≈Çuga opuszczenia canvas
        this.canvas.addEventListener('mouseleave', () => {
            if (this.pathfindingPointManager.isDraggingPoint()) {
                this.pathfindingPointManager.stopDragging();
                this.pathfindingUIController.updateAll(this.pathfindingPointManager);
            }
            
            // Wyczy≈õƒá pozycjƒô myszy
            const mousePositionElement = document.getElementById('mousePosition');
            if (mousePositionElement) {
                mousePositionElement.textContent = '-';
            }
            
            // Resetuj hover (ale zachowaj selected)
            this.inspector.setHoveredPoint(null);
            this.canvas.classList.remove('pointer-cursor');
            this.canvas.style.cursor = 'default';
            
            // Poka≈º selectedPoint je≈õli istnieje, inaczej ukryj inspector
            if (this.inspector.getSelectedPoint()) {
                this.inspector.showInspector(this.inspector.getSelectedPoint(), this.gameDataManager);
            } else {
                this.inspector.hideInspector();
            }
            
            // Renderuj mapƒô (mo≈ºe ukryƒá linie hover, ale zachowaƒá linie selected)
            this.renderMap();
            this.updateActivePointId();
        });
    }
    
    /**
     * AKTUALIZUJE GAMEDATA MANAGER Z PUNKTAMI PRZEJ≈öCIA I BUDUJE GRAF
     */
    updateGameDataManager() {
        if (!this.gameDataManager || !this.transitionPointManager) {
            return;
        }
        
        // Wyczy≈õƒá poprzednie punkty przej≈õcia
        this.gameDataManager.transitionPoints = [];
        
        // Pobierz punkty przej≈õcia z TransitionPointManager
        const transitionPoints = this.transitionPointManager.getTransitionPoints();
        
        // Konwertuj do nowego formatu i dodaj do GameDataManager
        transitionPoints.forEach(point => {
            // Sprawd≈∫ czy punkt ma wymagane w≈Ça≈õciwo≈õci
            if (point.chunkA && point.chunkB && point.x !== undefined && point.y !== undefined) {
                // Oblicz pozycjƒô lokalnƒÖ na podstawie kierunku
                let position;
                if (point.direction === 'vertical') {
                    position = point.x % this.settings.chunkSize;
                } else {
                    position = point.y % this.settings.chunkSize;
                }
                
                // Dodaj punkt z ID i connections
                this.gameDataManager.addTransitionPoint(point.chunkA, point.chunkB, position);
            }
        });
        
        // Zaktualizuj referencjƒô gameDataManager w Inspector'ze
        this.inspector.setGameDataManager(this.gameDataManager);
        
        // Graf po≈ÇƒÖcze≈Ñ bƒôdzie budowany na ≈ºƒÖdanie przez przycisk "Zbuduj Graf Przej≈õƒá"
        // this.gameDataManager.buildConnections(this.chunks);
        

    }
    
    /**
     * BUDUJE GRAF PO≈ÅƒÑCZE≈É MIƒòDZY PUNKTAMI PRZEJ≈öCIA
     */
    onBuildTransitionGraph() {
        // Upewnij siƒô ≈ºe mamy dane w GameDataManager
        if (!this.gameDataManager || this.gameDataManager.transitionPoints.length === 0) {
            this.pathfindingUIController.showError('Brak punkt√≥w przej≈õcia do zbudowania grafu');
            return;
        }
        
        // Buduj graf po≈ÇƒÖcze≈Ñ
        this.gameDataManager.buildConnections(this.chunks);
        
        // Zaktualizuj referencjƒô gameDataManager w Inspector'ze po zbudowaniu po≈ÇƒÖcze≈Ñ
        this.inspector.setGameDataManager(this.gameDataManager);
        
        // Poka≈º sukces
        this.pathfindingUIController.showSuccess('Zbudowano graf po≈ÇƒÖcze≈Ñ');
    }

    /**
     * DRUKUJE DANE GAME DATA MANAGER W KONSOLI
     */
    onPrintGameData() {
        console.log('=== GAMEDATA MANAGER PRINT ===');
        console.log('üìä GameDataManager Object:', this.gameDataManager);

        
        console.log('\nüìê Settings:');
        console.log(`- Chunk Size: ${this.gameDataManager.chunkWidth}x${this.gameDataManager.chunkHeight}`);
        console.log(`- Grid Size: ${this.gameDataManager.gridWidth}x${this.gameDataManager.gridHeight}`);
        console.log('- Total Transition Points:', this.gameDataManager.transitionPoints.length);
        console.log('- Total Chunks:', Object.keys(this.gameDataManager.chunks).length);
        
        console.log('\nüìã JSON Export (New Format):');
        console.log(JSON.stringify(this.gameDataManager.transitionPoints, null, 2));
        
        console.log('==============================');
        
        // Pokazuje te≈º sukces w UI
        this.pathfindingUIController.showSuccess('Dane wydrukowane w konsoli');
    }

    /**
     * KONFIGURUJE PRZYCISK "OBLICZ ≈öCIE≈ªKƒò"
     */
    setupCalculatePathButton() {
        const calculatePathBtn = document.getElementById('calculatePath');
        if (calculatePathBtn) {
            calculatePathBtn.addEventListener('click', () => {
                this.onCalculatePathfindingPath();
            });
        }
    }
}

// Inicjalizuj aplikacjƒô gdy DOM jest gotowy
document.addEventListener('DOMContentLoaded', () => {
    new ChunkMapGenerator();
}); 